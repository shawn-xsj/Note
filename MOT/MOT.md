# MOT

## Eigen

1.　数组和矩阵的关系

> **6 Array****和Matrix之间的转换**
>
> **WHY:**什么时候该使用矩阵？什么时候又使用数组？你不能对数组执行矩阵的运算，也不能对矩阵执行数组的运算。因此当你需要做线性代数的运算，比如矩阵乘积，那你应该使用矩阵。如果你要做元素级操作，你应该使用数组。然而有时事情并不那么容易，你可能需要同时使用数组和矩阵，这时候你就需要数组和矩阵之间的互相转换了。

**矩阵和数组到底什么联系？**

## DeepSort

１．https://blog.csdn.net/hailanglin/article/details/90370375?spm=1001.2014.3001.5501

> 
>
> 1. 8个状态量（目标框中心Ｘ，目标框中心Ｙ，宽高比，高度，**图像坐标系**下的四个数的导数）
>
> 　2. Amax = 30 从上一次匹配到现在，长时间没有匹配上的，这里设置的阈值是30，超过这个阈值的时间没有匹配上，这个track就要被删除；
>
>  3. 目标框的匹配采用了**运动匹配**和**外观匹配**,
>
>     其中==运动匹配是马氏距离匹配==，使用卡方分布的==0.95==分位点作为阈值：nis = (d - y)^T^S^(-1)^(d-y)  其中 d为观测，ｙ为预测，Ｓ为卡尔曼滤波的结果；
>
>     ==外观匹配是采用最小余弦距离==进行匹配，解决的是在实际情况中相机运动导致的马氏距离匹配失效的情况，假设最小余弦距离记为d_cos；
>
>     最后对两个匹配的结果进行融合 c = aＸnis +(1-a)*d_cos; 文中的ａ为０;
>
>  4. ==级联匹配==: TBD
>

2. https://blog.csdn.net/sgfmby1994/article/details/98517210

   > 1.  对已经存在的track分为confirmed track和unconfirm tracks(tentative);
   > 2. 针对已经confirmed track，与当前的检测结果进行级联匹配；
   > 3. unfirmed track和２中没有匹配上的track，一起组成iou_track,与还没有匹配上的结果进行IOU匹配；==IOU匹配的目的==:缓解因为表现突变或者部分遮挡导致的较大变化，这样做有可能导致一些新产生的轨迹被连接到一些旧的轨迹上，特别是tentative的的track；
   > 4. ==计算框两两之间的iou，经由１－ｉｏｕ　得到cost_matrix==
   > 5. ==track的状态好更新，~~那track的１２８维特征是否参与更新？如何更新？~~==: 匹配上的track的feature不进行更新，而是进行保存，最多保存最近与之匹配的100帧检测结果的feature.==为什么要保存100帧的feature?这100个feature是如何使用的？ＴＢＤ((xsj猜想：都参数余弦距离的计算)==
   > 6. ==feature 计算了余弦距离，形成了一个cost matrix，这个匹配的结果和cost matrix对马氏距离的匹配有什么作用？有什么影响(TBD)==
   > 7. ==为啥叫“级联匹配"==: 这个匹配操作需要从刚刚匹配成功的track循环遍历到最多已经有30次（cascade_depth)没有匹配的track; ==目的是: 给那些新鲜的track机会去先参与匹配，对那些已经有多次没有匹配上的track后参与匹配，加速这些多次没有匹配上的track的淘汰过程，因为这些多次没有匹配上的track本身已经不太准确了（~~ｘｓｊ的猜想，还没有证实~~,已经证实，正确）==
   > 8. 经历一次predict就经历一次预测，time_since_update 就＋１；
   > 9. 匹配的特征包括外观匹配和运动匹配，外观匹配是深度特征，采用最小余弦距离；运动匹配是运动状态信息，采用马氏距离；
   > 10. ==将经过马氏距离处理的矩阵cost_matrix继续由max_distance 处理，（程序中max_distance=0.2)得到处理过的cost_matrix:（ＴＢＤ）==
   > 11. ==对匹配结果进行筛选，删除两者差距较大的（ＴＢＤ）==





