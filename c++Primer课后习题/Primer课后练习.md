## 第二章

### 2.1

> 1. short，int，long, long long都是整型，int最少占１６位，long最少占３２位，long long 最少占64位，short也占１６位；==都占１６位short与int的区别是什么？==
> 2. 无符号型的所有位都表示数值，只能表示正数；有符号型的最高bit位表征正负，剩下的位表示数值；
> 3. float　32位，double　６４位，float 有效数字6位, double 有效数字10位; float 单精度浮点数，double双精度浮点数;

### 2.2

> 1. 利率：float
>
> 2. 本金: double;
>
> 3. 付款: double；
>
>    ==主要考虑计算代价和表示的范围==

### 2.3

> 32
>
> 4294967264
>
> 32
> -32
>
> 0
>
> 0
>
> ==无符号数的模：２^(所占位数)==
>
> ==带符号的数和不带符号的数一起运算时，会先将带符号的数转为不带符号的数==
>
> ==最好不要在一个运算式子中混用两个数据类型==

### 2.4

> 略

### 2.5

> a) 　字符，　宽字符，字符串，宽字符串
>
> b)    int,  unsigned int, long int , long unsigned int ,==八进制数，对应十进制数的10==,  十进制Ｃ；
>
> c) float, float, long ==double==
>
> d) ing ,unsigned int , float, float（科学计数法）

### 2.6

> 第一行是10进制
>
> 第二行是八进制：　09会报错吧

### 2.7

> a) ==转义字符==
>
> b) 长float, 科学计数法则:31.4
>
> c) float
>
> d)long  ==double==

### 2.8

> TBD

### 2.9

> a)  定义input_value，并将输入的值传递给它；==错误，输入运算符的右侧需要一个明确的变量名称，而非定义变量的语句==
>
> b) ~~错误，~~没有给数组的个数;==这是使用初始化列表的方式进行初始化，但是使用float去初始化int，　不妥==
>
> 
>
> c) 错误，不能连续赋值；==声明多个变量时应该用逗号将变量名隔开，而不能直接用赋值运算符连接, 但赋值的时候可以连续赋值==
>
> d) 定义一个int变量，初始化的值为3.14 ==警告: 数据类型不匹配==

### 2.10

> 1. 区分全局变量和局部变量；
> 2. 　==string　类别的变量无论是全局还是局部的，默认的初始化都是空串；==
> 3. 　global　int 默认的初始化为０，　local　int 默认是不被初始化；

### 2.11

> 1. ~~错误，extern不能赋值~~　　　定义
> 2. ~~声明~~　　定义
> 3. 声明
>
> ==extern是显式的声明，如果extern后面赋值了，就变成了定义，声明是为了告诉程序这个变量名称，定义的时候就已经申请了空间。变量能且只能被定义一次，但是可以被声明多次==

### 2.12

> 1. 非法，使用了Ｃ＋＋的保留关键字double
> 2. 不规范。可读性不好
> 3. 非法，连接线；
> 4. ~~合法~~　==只能以字母或者下划线开头，不能以数字开头==
> 5. 合法

### 2.13

> 100
>
> ==C++允许内层作用域重新定义外层作用域中已有的名字==

### 2.14

> 100, 45

### 2.15

==引用必须被初始化==

==引用不会产生新的拷贝==

==引用本身不是一个对象，所以不能定义引用的引用==

==引用的类型要与其绑定的对象的类型匹配==

==引用只能绑定在对象上，而不能绑定在一个具体的值或者某个表达式的计算结果上==

> 1. ~~不合法，类型不匹配~~  合法，但不合理，类型不匹配
>
> 2.  不合法，引用不能绑定在具体的值上
>
> 3. 合法
>
> 4. 不合法，　引用必须初始化；
>
>    

### 2.16

> 1. 合法
> 2. ~~不合法，类型不匹配~~ 合法，但不合理
> 3. ~~不合法，类型不匹配~~　合法，但不合理
> 4. ~~不合法，类型不匹配~~　合法，但不合理

### 2.17

> 10 10

### 2.18

==指针本身就是一个对象，允许指针之间进行赋值和拷贝==

==指针定义是可以不赋初值==

==引用不是对象，没有实际的地址，所以不能定义指向引用的指针==

==指针类型与所指向值的类型一定要匹配==

==解引用符(*)只适用于那些确实指向了某个对象的有效指针==

==空指针有三种方式：nullptr, 0,  NULL==

==尽量初始化所有的指针，如果实在不清楚指针应该指向何处，可以初始化为空指针==

==void* 是一种特殊指针，可以存放任意对象的地址==

==不能直接操作void*指针所指的对象，因为我们并不知道这个对象到底是什么类型,也就无法确定能在这个对象上做哪些操作==

> ```c++
> #include <iostream>
> int main()
> {
> 	int i=0, j=2;
>     int *p = &i;
>     *p = &j;
>     *p =3;
>     return 0;
> }
> ```

### 2.19 

> 1. 指针是真实的对象，引用不是，它是一个别名，是拷贝，可以进行拷贝和赋值；
> 2. 引用定义的时候必须初始化，且一旦初始化就与所指向的对象进行了绑定，不能更改，指针不是必须初始化；

### 2.20

> 1. i^2 

### 2.21 

> (a) 非法，double型指针，指向int型数据;
>
> (b) 非法，指针用int值来赋值；
>
> (c)合法；



### 2.22

> 1. 如果p不是空指针；
> 2. 如果Ｐ所指向的内容不为０;

### 2.23

> 1. try……catch
> 2. if 判断是否为null

### 2.24 

> 1. void能存放所有对象的地址，可以指向任意类型对象;
> 2. long 指针不能指向int型对象；

### 2.25

> ==引用本身不是对象，不能定义指向引用的指针，指针是对象，所以存在对指针的引用==
>
> 1. ip: int型指针；　ｉ　int 类型
> 2. int 变量　　int 指针，指向空；
> 3. int 指针，　int 变量；

### 2.26

==const 对象必须进行初始化==

==const 对象默认情况下只在文件内有效，当多个文件出现了同名的const变量时，其实等同于在不同文件中分别定义了独立的变量==

==如果想在多个文件之间共享const对象，必须在变量定义之前添加extern关键字==

> 1. 不合法，const变量定义要初始化
> 2. 合法
> 3. 合法
> 4. 不合法，const变量不能改变

### 2.27

> 1. ~~合法~~　==非常量引用不能引用字面值常量==
> 2. 合法
> 3. ~~不合法~~　　合法
> 4. ~~不合法~~　　合法
> 5. ~~不合法~~　　　合法
> 6. ~~合法~~　　==引用本身不是常量，不能让引用永恒不变==
> 7. 常量　常引用

### 2.28 

> a)  整数i,  常指针，指向int 类型（不合法，const没有初始化)
>
> b)  指向int的指针，指向int的常指针（不合法，const没有初始化)
>
> c) 常量，　常引用(不合法，常量没有初始化)
>
> d) 常指针指向常变量（不合法，没有初始化）
>
> e) 指向常变量的指针~~（==是否要初始化TBD==）~~ 不需要初始化，因为没有指向任何实际对象

### 2.29

> a) 正确
>
> b) 不正确
>
> c) 不正确 ==普通指针不能指向常量==
>
> d)不正确，常指针不能赋值
>
> e)不正确
>
> f) 不正确

### 2.30

> 不管顶层还是底层，只管const默认修饰左侧，否则修饰右侧

### 2.31

> 



### 2.32

> ==声明为constexpr类型的变量一定是一个常量，而且必须使用常量表达式进行初始化==
>
> 不合法，int型变量与int型指针不能直接绑定
>
> 使用nullptr

### 2.33

> ==using: 别名声明==
>
> ==不能简单的将类型别名替换成它本来的样子==
>
> ==auto 通过初始值推算变量的类型，因此auto定义的变量必须有初始值==
>
> ==使用auto语句时也需要注意，一条语句中如果有多个变量，多个变量的类型要一致==

### 2.34

### 2.35 

### 2.36

> ==decltype类型指示符：得到表达式的类型，却不实际计算表达式的值==
>
> ==最好不要把对象的定义和类的定义放在一起==



### 2.41

p67

### 2.42

> ==类所在头文件的名字应该与类的名字一样==
>
> ==预处理器==
>
> 
>
> 







### 8.1

> ==IO对象不能拷贝或者赋值==
>
> ==不能将形参或返回类型设置为流类型==
>
> ==进行io操作的函数通常以引用的方式传递或者返回流，读写一个io对象会改变其状态，因此传递和返回的引用不能是const==
>
> ==一个流一旦发生错误，其上后续的io操作都会失败，只有当一个流处于无错状态时，我们才可以从它读取数据,向它写入数据==
>
> ==当一个fstream对象被销毁时，close会自动被调用==
>
> ==文件模式==
>
> 

> ==以out模式打开文件会丢弃已有数据==
>
> ==app模式为append,　接下来的所有读写操作都在文件的末尾进行==
>
> 

## 9 顺序容器

> 1. vector: 可变大小数组；
>
>    deque:双端队列：支持快速随机访问，但是在中间插入或者删除数据的开销比较大；
>
>    list: 双向链表: 有额外的内存开销
>
>    forward_list: ==单向链表==; 有额外的内存开销，用于存放地址；
>
>    array: 固定大小数组;
>
>    string:用于字符的可变大小数组;
>
> 2. ==现代c++程序应该使用标准库容器，而不是更原始的数据结构，如内置数组==
>
> 3. ==通常，使用vector是最好的选择，除非你有很好的理由选择其他容器==
>
> 4. ==如果必须在中间位置插入元素，可以考虑在输入阶段使用list，一旦输入完成，将list的内容拷贝到vector中，此时可以进行随机访问==
>
> 5. 如果不确定应该使用哪种容器，可以在程序中使用vector和list公共的操作：使用迭代器，不使用下标操作，避免随机访问.
>
> 6. ==较旧的编译器可能需要在两个尖括号之间键入空格==
>
> 7. forward_list迭代器不支持递减运算符(--)
>
> 8. 迭代器所表示的范围是左闭合区间[begin, end)
>
> 9. 顺序容器可以接受一个大小和一个初始值的的构造方式;
>
> 10. array, 比原版的数组好用点
>
> 11. 容器赋值后，大小与右边容器大小相同；
>
> 12. swap 操作不对任何元素进行拷贝、删除或者插入操作，只是交换了两个容器的内部数据结构，因此操作的时间很短，在常数时间内完成；(array的操作除外)
>
> 13. ==统一使用非成员函数版本的swap是一个好习惯==
>
> 14. ==容器的关系运算符使用元素的关系运算符完成比较，只有当其元素也定义了相应的比较运算符时，才可以使用关系运算符来比较两个容器==
>
> 15. 顺序容器:vector, deque, list, forward_list, array, string
>
> 16. ==向一个vector, string, deque插入元素会使所有指向容器的迭代器、引用和指针失效==
>
> 17. ==除array和forward_list之外，每个顺序容器都支持push_back==
>
> 18. ==容器的元素是拷贝，往容器里面放元素，是拷贝了一份新的元素放到容器中，与原变量没有关联，后续对容器的操作与原元素无关==
>
> 19. ==每个insert都接受一个迭代器作为其第一个参数，指出了在容器中什么位置放置新元素，insert函数将元素插入到迭代器所指定的位置之前==
>
> 20. 有些容器不支持push_front，可以使用insert插入到容器的开始位置
>
> 21. insert可以对vector插入，但是会比较耗时
>
> 22. insert不能指向与目的位置相同的容器
>
> 23. insert也可以有返回值，返回的是一个迭代器，指向新插入的第一个元素
>
> 24. emplace: 直接接受存储元素的构造元素，直接构造，然后直接放到容器中; 在容器管理的内存空间中直接创建对象;
>
> 25. front 和　back分别返回首元素的引用;
>
> 26. 顺序容器中用来访问元素的成员函数（front, back, 下标, at) 返回的都是容器元素的引用;
>
>     ```c++
>     auto &v = c.back(); //返回指向最后一个元素的引用;
>     auto v2 = c.back(); //v2不是一个引用，它是c.back()的一个拷贝
>     ```
>
> 
>
> 27. 下标运算符不检查下标是否在合法的范围内, at函数会抛出一个out_of_range的异常;
>
> 28. 在删除元素前，必须确保它们是存在的;
>
> 29. 若ｊ是ｉ之后的元素，那么erase(i) 返回指向j的迭代器(erase返回指向删除元素之后位置的迭代器)
>
> 30. erase可以删除一个一对迭代器之间的所有元素;
>
> 31. clear删除所有元素
>
> 32. ==单向链表(forward_list)添加或者删除一个元素时,需要访问其前驱，以便改变前驱的链接==
>
> 33. resize 如果改变的是存放类的容器，必须提供初始值;
>
> 34. 向容器中添加元素和从容器中删除元素的操作可能会使指向容器元素的：指针，引用或者迭代器失效;
>
> 35. 必须保证每次改变容器的操作之后，都正确地重新定位迭代器;
>
> 36. 管理容器的容量(只针对vector和string)：
>
>     > 1.capacity:　在不扩张内存的情况下可以容纳多少个元素;
>     >
>     > 2.reserve:　分配至少容纳n个元素的内存空间;(但不会减少内存空间)
>
> 37. 
>
> 38. string　的额外操作
>
>     > 1. 其他３种构造函数;
>     >
>     > 2. 子字符串操作substr(pos, n)
>     >
>     > 3. 除了迭代器版本的insert和erase外，还有下标版本的；
>     >
>     > 4. append: 末尾增加;
>     >
>     > 5. replace: erase和insert的合并;
>     >
>     > 6. assigen: 指定替换;
>     >
>     > 7. string的搜索函数返回的是一个unsigned类型，用一个int或其他带符号的类型来保存这写函数的返回值是不合适的;
>     >
>     > 8. find:找指定的字符串, 若找到，返回第一个匹配位置的下标; 否则返回npos；
>     >
>     >    find(args)：返回的是args第一次出现的位置;
>     >
>     >    rfind(args): 返回的是args最后一次出现的位置；
>     >
>     >    find还可以指定从哪个地方开始搜索;
>     >
>     > 9. compare与ｃ中的strcmp类似;
>     >
>     > 10. 数值转换函数：要转换成数值的string中第一个非空白符必须是数值中可能出现的字符;
>     >
>     >     to_string; 
>     >
>     >     stoi;
>     >
>     >     stol;
>     >
>     >     stod;
>     >
>     >     stof;
>
> 39.  ### 容器适配器
>
>     > ==适配器: 标准库类型、函数或迭代器，它们接受了一个类型、函数或迭代器，使其行为像另外一个类型、函数或迭代器一样。标准库提供了三种顺序容器适配器:stack、queue和priority_queue。每个适配器都在其底层顺序容器类型之上定义了一个新的接口==
>     >
>     > 1. stack；
>     > 2. 栈适配器;
>     > 3. 队列适配器;



## 　泛型算法

### 概述

> 1.  这些算法是通用的，可用于不同的类型或容器元素;
>
> 2. 大多数算法在algorithm中，另外在numeric中定义了一组数值泛型算法;
>
> 3. ==这些算法并不直接操作容器，而是遍历由两个迭代器制定的一个元素范围来进行操作==
>
> 4. ```c++
>    int ia[] = {12, 34,43,5,4,64,6,3};
>    int val = 83;
>    int *result = find(begin(ia), end(ia), val);
>    ```
>
>    使用标准库begin和end函数来获得指向ia中首元素和尾元素之后位置的指针，并传递给find
>
> 5. 迭代器算法不依赖于容器, 但算法依赖于元素类型的操作;

### 初识泛型算法

> 1. 标准库算法都对一个范围内的元素进行操作，元素范围称为"输入范围"。接受输入范围的算法总是使用前两个参数来表示范围，两个参数分别指向要处理的第一个元素和尾元素之后位置的迭代器;
> 2. 对元素的操作可以分为: 读取元素、改变元素或者是重新排元素;

#### 只读算法

> 1. 只读取输入范围内的元素，不改变元素;
> 2. find
> 3. count
> 4. accumulate: 第三个元素代表初值，其类型决定了函数中使用哪个加法运算符以及返回值的类型,前两个元素的类型必须与第三个元素匹配；
> 5. 对于只读取而不改变元素的算法，通常最好使用cbegin()　和cend()
> 6. equal: 确定两个序列是否保存相同的值,　前两个元素表示第一个序列的范围，第三个表示第二个序列的首元素;(假定第二个序列至少与第一个序列一样长)

#### 写容器的算法

> 1. 需要确保容器能够容纳要写入的元素;
> 2. fill: 将给定的值赋予输入序列中的每个元素;
> 3. fill_n(dest, n, val):dest指向一个元素，从dest开始的ｎ个元素，赋值为val;(注意不能越界)
> 4. ==back_inserter==
> 5. 拷贝算法copy: 把a1的内容拷贝给a2;
> 6. 拷贝算法replace 
> 7. 拷贝算法replace_copy

#### 重排容器元素的算法

> 1. sort: 利用元素类型的<运算符来实现排序;
> 2. unique: 将重复的元素都放到最后面，返回一个指向最后一个不重复的位置的迭代器;
> 3. 向算法传递元素
> 4. stable_sort: 保持等长元素的字典序;
> 5. 算法只能接受==一元谓词==或==二元谓词==, 当需要接受多个谓词时，使用lambda表达式;
> 6. find_if: 只接受一元谓词;
> 7. lambda: 向一个算法传递任何类别的可调用对象,一个lambda表达式表示一个可调用的代码单元，可以理解为一个未命名的内联函数;
> 8. lambda表达式的形参不能有默认值;
> 9. 捕获列表：　空捕获列表表示不使用它所在函数中的任何局部变量,捕获列表指引lambda在其内部包含访问局部变量所需的信息; 一个捕获列表可以捕获多个局部变量;(捕获列表只用于局部非static变量)
> 10. ==lambda捕获与返回==
> 11. ==当以引用方式捕获变量时，必须保证lambda执行时变量存在==
> 12. ==应该尽量减少捕获的数据量，而且有可能的话，应该避免捕获指针或引用==
> 13. 隐式捕获: =为值捕获，＆为引用捕获;
> 14. ==默认情况下，对于一个值被拷贝的变量，lambda不会改变其值，如果希望能改变一个被捕获的变量的值，就必须在参数列表首加上关键字mutable==
> 15. 只有一两个地方使用的简单操作，lambda表达式最有用，如果需要很多地方使用相同的操作，通常要定义一个函数，而不是多次编写相同的lambda表达式。如果一个操作需要很多语句才能完成，通常需要使用函数;
> 16. ==bind函数==:　通用的函数适配器，接受一个可调用的对象，生成一个新的可调用的对象来“适应”原对象的参数列表;
>
> 

#### 再探迭代器

> 1. 插入迭代器, 流迭代器,  反向迭代器, 移动迭代器
> 2. 插入迭代器: back_inserter(使用push_back进行迭代), front_inserter(使用push_front的迭代器), inserter(接收两个参数, 将元素插入到给定迭代器所表示的元素之前)
> 3. iostream迭代器: istream_iterator:读取输入流; ostream_iterator: 向一个输出流写数据;
> 4. ostream_iterator
> 5. 除了forward_list之外，其他容器都支持反向迭代器;

> 



















































